---
phase: 01-booking-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/api/businesses/[id]/services/route.ts
  - app/api/businesses/[id]/availability/route.ts
  - lib/mock-data/client.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/businesses/[id]/services returns list of active services"
    - "POST /api/businesses/[id]/services creates a new service"
    - "GET /api/businesses/[id]/availability returns available time slots for a date"
    - "APIs work in both real and mock mode"
  artifacts:
    - path: "app/api/businesses/[id]/services/route.ts"
      provides: "Service CRUD API"
      exports: ["GET", "POST", "PUT", "DELETE"]
    - path: "app/api/businesses/[id]/availability/route.ts"
      provides: "Availability slots API"
      exports: ["GET"]
  key_links:
    - from: "services/route.ts"
      to: "prisma.service"
      via: "database queries"
      pattern: "db\\.service\\."
    - from: "availability/route.ts"
      to: "lib/availability.ts"
      via: "generateTimeSlots import"
      pattern: "import.*generateTimeSlots.*from"
---

<objective>
Create API routes for service management and availability slot generation.

Purpose: The booking flow needs APIs to fetch business services (for service selection) and available time slots (for calendar/time picker). These routes connect the frontend to the database.

Output: Service CRUD API and availability API routes.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-booking-foundation/01-RESEARCH.md

# Existing API patterns
@app/api/bookings/route.ts
@lib/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Service CRUD API routes</name>
  <files>app/api/businesses/[id]/services/route.ts</files>
  <action>
Create `app/api/businesses/[id]/services/route.ts`:

```typescript
import { NextResponse } from "next/server";
import { db, isMockMode } from "@/lib/db";

// GET /api/businesses/[id]/services - Get services for a business
export async function GET(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: businessId } = await params;
    const { searchParams } = new URL(req.url);
    const activeOnly = searchParams.get("active") !== "false";

    const services = await db.service.findMany({
      where: {
        businessId,
        ...(activeOnly ? { isActive: true } : {}),
      },
      orderBy: [{ sortOrder: "asc" }, { name: "asc" }],
    });

    return NextResponse.json({ services });
  } catch (error) {
    console.error("Error fetching services:", error);
    return NextResponse.json({ error: "Failed to fetch services" }, { status: 500 });
  }
}

// POST /api/businesses/[id]/services - Create a new service
export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: businessId } = await params;
    let userId: string | null = null;

    if (isMockMode()) {
      userId = req.headers.get("x-user-id");
    }

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify user owns this business
    const business = await db.business.findUnique({
      where: { id: businessId },
    });

    if (!business || business.ownerId !== userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    const body = await req.json();
    const { name, description, price, priceType, duration, category, isFeatured, sortOrder } = body;

    // Validation
    if (!name || price === undefined || !duration) {
      return NextResponse.json(
        { error: "name, price, and duration are required" },
        { status: 400 }
      );
    }

    if (duration < 1 || duration > 480) {
      return NextResponse.json(
        { error: "Duration must be between 1 and 480 minutes" },
        { status: 400 }
      );
    }

    if (price < 0) {
      return NextResponse.json(
        { error: "Price cannot be negative" },
        { status: 400 }
      );
    }

    const service = await db.service.create({
      data: {
        businessId,
        name,
        description: description || null,
        price: parseFloat(price),
        priceType: priceType || "fixed",
        duration: parseInt(duration),
        category: category || null,
        isFeatured: isFeatured || false,
        sortOrder: sortOrder || 0,
        isActive: true,
      },
    });

    return NextResponse.json({ service }, { status: 201 });
  } catch (error) {
    console.error("Error creating service:", error);
    return NextResponse.json({ error: "Failed to create service" }, { status: 500 });
  }
}

// PUT /api/businesses/[id]/services - Update a service (serviceId in body)
export async function PUT(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: businessId } = await params;
    let userId: string | null = null;

    if (isMockMode()) {
      userId = req.headers.get("x-user-id");
    }

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify user owns this business
    const business = await db.business.findUnique({
      where: { id: businessId },
    });

    if (!business || business.ownerId !== userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    const body = await req.json();
    const { serviceId, name, description, price, priceType, duration, category, isFeatured, isActive, sortOrder } = body;

    if (!serviceId) {
      return NextResponse.json({ error: "serviceId is required" }, { status: 400 });
    }

    // Verify service belongs to this business
    const existingService = await db.service.findUnique({
      where: { id: serviceId },
    });

    if (!existingService || existingService.businessId !== businessId) {
      return NextResponse.json({ error: "Service not found" }, { status: 404 });
    }

    const service = await db.service.update({
      where: { id: serviceId },
      data: {
        ...(name !== undefined && { name }),
        ...(description !== undefined && { description }),
        ...(price !== undefined && { price: parseFloat(price) }),
        ...(priceType !== undefined && { priceType }),
        ...(duration !== undefined && { duration: parseInt(duration) }),
        ...(category !== undefined && { category }),
        ...(isFeatured !== undefined && { isFeatured }),
        ...(isActive !== undefined && { isActive }),
        ...(sortOrder !== undefined && { sortOrder }),
      },
    });

    return NextResponse.json({ service });
  } catch (error) {
    console.error("Error updating service:", error);
    return NextResponse.json({ error: "Failed to update service" }, { status: 500 });
  }
}

// DELETE /api/businesses/[id]/services - Delete a service (serviceId in query)
export async function DELETE(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: businessId } = await params;
    const { searchParams } = new URL(req.url);
    const serviceId = searchParams.get("serviceId");

    let userId: string | null = null;

    if (isMockMode()) {
      userId = req.headers.get("x-user-id");
    }

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!serviceId) {
      return NextResponse.json({ error: "serviceId query param is required" }, { status: 400 });
    }

    // Verify user owns this business
    const business = await db.business.findUnique({
      where: { id: businessId },
    });

    if (!business || business.ownerId !== userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
    }

    // Verify service belongs to this business
    const existingService = await db.service.findUnique({
      where: { id: serviceId },
    });

    if (!existingService || existingService.businessId !== businessId) {
      return NextResponse.json({ error: "Service not found" }, { status: 404 });
    }

    await db.service.delete({
      where: { id: serviceId },
    });

    return NextResponse.json({ message: "Service deleted" });
  } catch (error) {
    console.error("Error deleting service:", error);
    return NextResponse.json({ error: "Failed to delete service" }, { status: 500 });
  }
}
```
  </action>
  <verify>Run `npm run build` to ensure the API route compiles. Test with curl: `curl http://localhost:3000/api/businesses/test-id/services` (should return empty array or error if business doesn't exist).</verify>
  <done>Service CRUD API exists with GET, POST, PUT, DELETE methods that validate ownership and handle errors</done>
</task>

<task type="auto">
  <name>Task 2: Create Availability API route</name>
  <files>app/api/businesses/[id]/availability/route.ts</files>
  <action>
Create `app/api/businesses/[id]/availability/route.ts`:

```typescript
import { NextResponse } from "next/server";
import { db } from "@/lib/db";
import { generateTimeSlots } from "@/lib/availability";
import { startOfDay, endOfDay, format } from "date-fns";

// GET /api/businesses/[id]/availability?date=YYYY-MM-DD&duration=60
export async function GET(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: businessId } = await params;
    const { searchParams } = new URL(req.url);
    const dateStr = searchParams.get("date");
    const durationStr = searchParams.get("duration");

    if (!dateStr) {
      return NextResponse.json({ error: "date query param is required (YYYY-MM-DD)" }, { status: 400 });
    }

    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      return NextResponse.json({ error: "Invalid date format" }, { status: 400 });
    }

    const serviceDuration = durationStr ? parseInt(durationStr) : 60;
    const dayOfWeek = date.getDay();

    // Get business availability for this day of week
    const availability = await db.businessAvailability.findUnique({
      where: {
        businessId_dayOfWeek: { businessId, dayOfWeek },
      },
    });

    if (!availability || !availability.isAvailable) {
      return NextResponse.json({
        slots: [],
        message: "Business is closed on this day",
        dayOfWeek,
        isOpen: false,
      });
    }

    // Check for exception on this specific date
    const exception = await db.availabilityException.findUnique({
      where: {
        businessId_date: { businessId, date: startOfDay(date) },
      },
    });

    if (exception && !exception.isAvailable) {
      return NextResponse.json({
        slots: [],
        message: exception.reason || "Business is closed on this date",
        isOpen: false,
        exception: {
          reason: exception.reason,
        },
      });
    }

    // If exception exists with modified hours, use those instead
    const effectiveAvailability = exception?.isAvailable && exception.startTime && exception.endTime
      ? {
          startTime: exception.startTime,
          endTime: exception.endTime,
          slotDuration: availability.slotDuration,
          bufferTime: availability.bufferTime,
          isAvailable: true,
        }
      : {
          startTime: availability.startTime,
          endTime: availability.endTime,
          slotDuration: availability.slotDuration,
          bufferTime: availability.bufferTime,
          isAvailable: availability.isAvailable,
        };

    // Get existing bookings for this date
    const existingBookings = await db.booking.findMany({
      where: {
        businessId,
        appointmentDate: {
          gte: startOfDay(date),
          lte: endOfDay(date),
        },
        status: {
          in: ["PENDING", "CONFIRMED"],
        },
      },
      select: {
        appointmentTime: true,
        duration: true,
      },
    });

    // Generate available time slots
    const slots = generateTimeSlots(
      effectiveAvailability,
      existingBookings,
      date,
      serviceDuration
    );

    return NextResponse.json({
      slots,
      date: format(date, "yyyy-MM-dd"),
      dayOfWeek,
      isOpen: true,
      hours: {
        start: effectiveAvailability.startTime,
        end: effectiveAvailability.endTime,
      },
      serviceDuration,
    });
  } catch (error) {
    console.error("Error fetching availability:", error);
    return NextResponse.json({ error: "Failed to fetch availability" }, { status: 500 });
  }
}
```

This API:
- Takes date and optional duration query params
- Checks BusinessAvailability for the day of week
- Checks AvailabilityException for date-specific overrides
- Fetches existing PENDING/CONFIRMED bookings for the date
- Uses generateTimeSlots to compute available slots
- Returns slot array with availability status
  </action>
  <verify>Run `npm run build` to ensure the API route compiles without errors.</verify>
  <done>Availability API exists that returns time slots for a given date, considering business hours and existing bookings</done>
</task>

<task type="auto">
  <name>Task 3: Add mock data support for Service model</name>
  <files>lib/mock-data/client.ts</files>
  <action>
Update `lib/mock-data/client.ts` to add mock support for the Service model. Find the mock client implementation and add:

1. Add mock services data array near the top of the file (after other mock data):

```typescript
const mockServices: any[] = [
  {
    id: "service-1",
    businessId: "business-1",
    name: "Basic Consultation",
    description: "30-minute consultation session",
    price: 50.00,
    priceType: "fixed",
    duration: 30,
    category: "Consultation",
    isActive: true,
    isFeatured: true,
    sortOrder: 0,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  {
    id: "service-2",
    businessId: "business-1",
    name: "Full Service",
    description: "Complete 1-hour service with all amenities",
    price: 100.00,
    priceType: "fixed",
    duration: 60,
    category: "Premium",
    isActive: true,
    isFeatured: false,
    sortOrder: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
```

2. Add service model methods to the mockClient object:

```typescript
service: {
  findMany: async ({ where, orderBy }: any = {}) => {
    let result = [...mockServices];
    if (where?.businessId) {
      result = result.filter(s => s.businessId === where.businessId);
    }
    if (where?.isActive !== undefined) {
      result = result.filter(s => s.isActive === where.isActive);
    }
    return result;
  },
  findUnique: async ({ where }: any) => {
    if (where?.id) {
      return mockServices.find(s => s.id === where.id) || null;
    }
    return null;
  },
  create: async ({ data }: any) => {
    const newService = {
      id: `service-${Date.now()}`,
      ...data,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    mockServices.push(newService);
    return newService;
  },
  update: async ({ where, data }: any) => {
    const index = mockServices.findIndex(s => s.id === where.id);
    if (index === -1) throw new Error("Service not found");
    mockServices[index] = { ...mockServices[index], ...data, updatedAt: new Date() };
    return mockServices[index];
  },
  delete: async ({ where }: any) => {
    const index = mockServices.findIndex(s => s.id === where.id);
    if (index === -1) throw new Error("Service not found");
    const deleted = mockServices.splice(index, 1)[0];
    return deleted;
  },
},
```

If the mock client uses a different pattern, adapt accordingly - the key is ensuring `db.service.findMany()` etc. work in mock mode.
  </action>
  <verify>With USE_MOCK_DATA=true, the service API should return mock data. Test: `curl http://localhost:3000/api/businesses/business-1/services` with mock mode headers.</verify>
  <done>Mock data client supports Service model with findMany, findUnique, create, update, delete operations</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` completes without errors
- [ ] GET /api/businesses/[id]/services returns services array
- [ ] POST /api/businesses/[id]/services creates a service (with auth)
- [ ] GET /api/businesses/[id]/availability?date=YYYY-MM-DD returns slots array
- [ ] Mock mode works for service operations
</verification>

<success_criteria>
- Service CRUD API handles GET (list), POST (create), PUT (update), DELETE operations
- Service API validates ownership (only business owner can modify)
- Availability API returns time slots based on BusinessAvailability and existing bookings
- Both APIs work in mock mode (USE_MOCK_DATA=true)
- All routes compile and handle errors gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-booking-foundation/01-03-SUMMARY.md`
</output>
