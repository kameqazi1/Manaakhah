---
phase: 01-booking-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-03"]
files_modified:
  - app/dashboard/services/page.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard services page loads services from API, not localStorage"
    - "Creating a service persists to database"
    - "Editing a service updates the database"
    - "Deleting a service removes from database"
  artifacts:
    - path: "app/dashboard/services/page.tsx"
      provides: "Service management UI connected to API"
      min_lines: 300
  key_links:
    - from: "app/dashboard/services/page.tsx"
      to: "/api/businesses/[id]/services"
      via: "fetch calls"
      pattern: "fetch.*api/businesses.*services"
---

<objective>
Migrate the dashboard services page from localStorage to use the new Service API.

Purpose: The current `/dashboard/services` page stores services in localStorage, which means data doesn't persist across devices or browsers. This migration connects it to the real database via the Service API created in Plan 03.

Output: Updated services page that performs CRUD operations via API.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-booking-foundation/01-RESEARCH.md

# Current implementation to migrate
@app/dashboard/services/page.tsx

# API routes (from Plan 03)
# GET/POST/PUT/DELETE /api/businesses/[id]/services
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate services page to use API</name>
  <files>app/dashboard/services/page.tsx</files>
  <action>
Update `app/dashboard/services/page.tsx` to use the Service API instead of localStorage. Key changes:

1. Add state for businessId and loading/error states
2. Fetch business ID from user's businesses on mount
3. Replace localStorage operations with API calls
4. Add proper error handling and loading states

Replace the entire file with:

```typescript
"use client";

import { useState, useEffect, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useMockSession } from "@/components/mock-session-provider";
import Link from "next/link";

interface Service {
  id: string;
  name: string;
  description: string | null;
  price: number;
  priceType: "fixed" | "starting" | "hourly" | "custom";
  duration: number;
  category: string | null;
  isActive: boolean;
  isFeatured: boolean;
  sortOrder: number;
}

const PRICE_TYPES = [
  { value: "fixed", label: "Fixed Price" },
  { value: "starting", label: "Starting From" },
  { value: "hourly", label: "Per Hour" },
  { value: "custom", label: "Contact for Quote" },
];

export default function ServiceMenuPage() {
  const { data: session, mockHeaders } = useMockSession();
  const [services, setServices] = useState<Service[]>([]);
  const [businessId, setBusinessId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [showServiceModal, setShowServiceModal] = useState(false);
  const [editingService, setEditingService] = useState<Service | null>(null);

  const [serviceForm, setServiceForm] = useState({
    name: "",
    description: "",
    price: 0,
    priceType: "fixed" as Service["priceType"],
    duration: 60,
    category: "",
    isFeatured: false,
  });

  // Fetch user's business ID
  useEffect(() => {
    const fetchBusiness = async () => {
      if (!session?.user?.id) return;

      try {
        const response = await fetch("/api/businesses/my", {
          headers: mockHeaders,
        });

        if (response.ok) {
          const data = await response.json();
          if (data.businesses && data.businesses.length > 0) {
            setBusinessId(data.businesses[0].id);
          }
        }
      } catch (err) {
        console.error("Error fetching business:", err);
      }
    };

    fetchBusiness();
  }, [session?.user?.id, mockHeaders]);

  // Fetch services when businessId is available
  const fetchServices = useCallback(async () => {
    if (!businessId) return;

    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/businesses/${businessId}/services?active=false`, {
        headers: mockHeaders,
      });

      if (response.ok) {
        const data = await response.json();
        setServices(data.services || []);
      } else {
        const errData = await response.json();
        setError(errData.error || "Failed to load services");
      }
    } catch (err) {
      console.error("Error fetching services:", err);
      setError("Failed to load services");
    } finally {
      setLoading(false);
    }
  }, [businessId, mockHeaders]);

  useEffect(() => {
    if (businessId) {
      fetchServices();
    }
  }, [businessId, fetchServices]);

  const handleServiceSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!businessId) return;

    setSaving(true);
    setError(null);

    try {
      const url = `/api/businesses/${businessId}/services`;
      const method = editingService ? "PUT" : "POST";

      const body = editingService
        ? { serviceId: editingService.id, ...serviceForm }
        : serviceForm;

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
          ...mockHeaders,
        },
        body: JSON.stringify(body),
      });

      if (response.ok) {
        await fetchServices();
        resetServiceForm();
      } else {
        const errData = await response.json();
        setError(errData.error || "Failed to save service");
      }
    } catch (err) {
      console.error("Error saving service:", err);
      setError("Failed to save service");
    } finally {
      setSaving(false);
    }
  };

  const resetServiceForm = () => {
    setServiceForm({
      name: "",
      description: "",
      price: 0,
      priceType: "fixed",
      duration: 60,
      category: "",
      isFeatured: false,
    });
    setShowServiceModal(false);
    setEditingService(null);
  };

  const handleEditService = (service: Service) => {
    setEditingService(service);
    setServiceForm({
      name: service.name,
      description: service.description || "",
      price: service.price,
      priceType: service.priceType,
      duration: service.duration,
      category: service.category || "",
      isFeatured: service.isFeatured,
    });
    setShowServiceModal(true);
  };

  const handleToggleAvailability = async (service: Service) => {
    if (!businessId) return;

    try {
      const response = await fetch(`/api/businesses/${businessId}/services`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          ...mockHeaders,
        },
        body: JSON.stringify({
          serviceId: service.id,
          isActive: !service.isActive,
        }),
      });

      if (response.ok) {
        await fetchServices();
      }
    } catch (err) {
      console.error("Error toggling service:", err);
    }
  };

  const handleDeleteService = async (serviceId: string) => {
    if (!businessId) return;
    if (!confirm("Are you sure you want to delete this service?")) return;

    try {
      const response = await fetch(
        `/api/businesses/${businessId}/services?serviceId=${serviceId}`,
        {
          method: "DELETE",
          headers: mockHeaders,
        }
      );

      if (response.ok) {
        await fetchServices();
      }
    } catch (err) {
      console.error("Error deleting service:", err);
    }
  };

  const formatPrice = (service: Service) => {
    if (service.priceType === "custom") return "Contact for Quote";
    const priceStr = `$${service.price.toFixed(2)}`;
    switch (service.priceType) {
      case "starting":
        return `From ${priceStr}`;
      case "hourly":
        return `${priceStr}/hr`;
      default:
        return priceStr;
    }
  };

  // Group services by category
  const servicesByCategory = services.reduce((acc, service) => {
    const cat = service.category || "Uncategorized";
    if (!acc[cat]) acc[cat] = [];
    acc[cat].push(service);
    return acc;
  }, {} as Record<string, Service[]>);

  if (!session?.user) {
    return (
      <div className="container mx-auto px-4 py-8">
        <Card>
          <CardContent className="p-8 text-center">
            <p className="text-gray-600">Please log in to manage services.</p>
            <Link href="/auth/signin">
              <Button className="mt-4">Sign In</Button>
            </Link>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!businessId && !loading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <Card>
          <CardContent className="p-8 text-center">
            <p className="text-gray-600">You don&apos;t have a business yet.</p>
            <Link href="/dashboard/business/new">
              <Button className="mt-4">Create Business</Button>
            </Link>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-3xl font-bold">Service Menu</h1>
          <p className="text-gray-600">Manage your services and pricing</p>
        </div>
        <div className="flex gap-2">
          <Link href="/dashboard">
            <Button variant="outline">Back to Dashboard</Button>
          </Link>
          <Button onClick={() => setShowServiceModal(true)}>+ Add Service</Button>
        </div>
      </div>

      {error && (
        <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
          {error}
        </div>
      )}

      {/* Stats */}
      <div className="grid md:grid-cols-4 gap-4 mb-6">
        <Card>
          <CardContent className="p-4">
            <div className="text-2xl font-bold text-blue-600">{services.length}</div>
            <div className="text-sm text-gray-600">Total Services</div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="text-2xl font-bold text-green-600">
              {services.filter((s) => s.isActive).length}
            </div>
            <div className="text-sm text-gray-600">Available</div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="text-2xl font-bold text-purple-600">
              {Object.keys(servicesByCategory).length}
            </div>
            <div className="text-sm text-gray-600">Categories</div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="text-2xl font-bold text-orange-600">
              {services.filter((s) => s.isFeatured).length}
            </div>
            <div className="text-sm text-gray-600">Featured</div>
          </CardContent>
        </Card>
      </div>

      {/* Service List */}
      {loading ? (
        <div className="text-center py-8">Loading services...</div>
      ) : services.length === 0 ? (
        <Card>
          <CardContent className="p-8 text-center">
            <span className="text-4xl block mb-4">ðŸ“‹</span>
            <h3 className="font-semibold text-lg mb-2">No services yet</h3>
            <p className="text-gray-600 mb-4">Add your services with pricing!</p>
            <Button onClick={() => setShowServiceModal(true)}>Add Service</Button>
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-6">
          {Object.entries(servicesByCategory).map(([category, categoryServices]) => (
            <Card key={category}>
              <CardHeader>
                <CardTitle>{category}</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {categoryServices.map((service) => (
                    <div
                      key={service.id}
                      className={`flex items-start justify-between p-3 rounded-lg border ${
                        !service.isActive
                          ? "bg-gray-50 opacity-60"
                          : service.isFeatured
                          ? "bg-yellow-50 border-yellow-200"
                          : ""
                      }`}
                    >
                      <div className="flex-1">
                        <div className="flex items-center gap-2">
                          <span className="font-semibold">{service.name}</span>
                          {service.isFeatured && (
                            <span className="px-2 py-0.5 rounded-full text-xs bg-yellow-100 text-yellow-700">
                              Featured
                            </span>
                          )}
                          {!service.isActive && (
                            <span className="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-600">
                              Unavailable
                            </span>
                          )}
                        </div>
                        {service.description && (
                          <p className="text-sm text-gray-600 mt-1">{service.description}</p>
                        )}
                        <p className="text-xs text-gray-500 mt-1">
                          Duration: {service.duration} min
                        </p>
                      </div>
                      <div className="flex items-center gap-4">
                        <span className="font-bold text-green-600">{formatPrice(service)}</span>
                        <div className="flex gap-1">
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleEditService(service)}
                          >
                            Edit
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleToggleAvailability(service)}
                          >
                            {service.isActive ? "Hide" : "Show"}
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            className="text-red-600"
                            onClick={() => handleDeleteService(service.id)}
                          >
                            Delete
                          </Button>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      {/* Service Modal */}
      {showServiceModal && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <Card className="w-full max-w-lg max-h-[90vh] overflow-y-auto">
            <CardHeader>
              <CardTitle>{editingService ? "Edit Service" : "Add New Service"}</CardTitle>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleServiceSubmit} className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">Service Name *</label>
                  <Input
                    required
                    placeholder="e.g., Oil Change"
                    value={serviceForm.name}
                    onChange={(e) => setServiceForm({ ...serviceForm, name: e.target.value })}
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">Description</label>
                  <Textarea
                    placeholder="Describe what's included..."
                    value={serviceForm.description}
                    onChange={(e) =>
                      setServiceForm({ ...serviceForm, description: e.target.value })
                    }
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">Category</label>
                  <Input
                    placeholder="e.g., Maintenance, Premium"
                    value={serviceForm.category}
                    onChange={(e) => setServiceForm({ ...serviceForm, category: e.target.value })}
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium mb-1">Price Type</label>
                    <select
                      className="w-full p-2 border rounded-md"
                      value={serviceForm.priceType}
                      onChange={(e) =>
                        setServiceForm({
                          ...serviceForm,
                          priceType: e.target.value as Service["priceType"],
                        })
                      }
                    >
                      {PRICE_TYPES.map((type) => (
                        <option key={type.value} value={type.value}>
                          {type.label}
                        </option>
                      ))}
                    </select>
                  </div>

                  {serviceForm.priceType !== "custom" && (
                    <div>
                      <label className="block text-sm font-medium mb-1">Price ($) *</label>
                      <Input
                        type="number"
                        min="0"
                        step="0.01"
                        required
                        value={serviceForm.price}
                        onChange={(e) =>
                          setServiceForm({ ...serviceForm, price: parseFloat(e.target.value) || 0 })
                        }
                      />
                    </div>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">Duration (minutes) *</label>
                  <Input
                    type="number"
                    min="1"
                    max="480"
                    required
                    value={serviceForm.duration}
                    onChange={(e) =>
                      setServiceForm({ ...serviceForm, duration: parseInt(e.target.value) || 60 })
                    }
                  />
                </div>

                <div className="flex items-center gap-2">
                  <input
                    type="checkbox"
                    id="isFeatured"
                    checked={serviceForm.isFeatured}
                    onChange={(e) =>
                      setServiceForm({ ...serviceForm, isFeatured: e.target.checked })
                    }
                    className="w-4 h-4"
                  />
                  <label htmlFor="isFeatured" className="text-sm">
                    Feature this service (highlight on profile)
                  </label>
                </div>

                <div className="flex gap-2 pt-4">
                  <Button type="submit" className="flex-1" disabled={saving}>
                    {saving ? "Saving..." : editingService ? "Save Changes" : "Add Service"}
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={resetServiceForm}
                    className="flex-1"
                  >
                    Cancel
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}
```

Key changes from original:
- Removed localStorage usage entirely
- Added businessId state fetched from `/api/businesses/my`
- All CRUD operations use `/api/businesses/[id]/services` API
- Simplified by removing separate category management (categories are derived from service.category)
- Added proper loading/error states
- Added saving state for form submission
  </action>
  <verify>Run `npm run build` to ensure no TypeScript errors. Test by navigating to /dashboard/services (with a logged-in business owner) - should load services from API.</verify>
  <done>Dashboard services page fetches from API, creates/updates/deletes via API, no localStorage usage</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/businesses/my endpoint if missing</name>
  <files>app/api/businesses/my/route.ts</files>
  <action>
Check if `/api/businesses/my/route.ts` exists. If not, create it:

```typescript
import { NextResponse } from "next/server";
import { db, isMockMode } from "@/lib/db";

// GET /api/businesses/my - Get current user's businesses
export async function GET(req: Request) {
  try {
    let userId: string | null = null;

    if (isMockMode()) {
      userId = req.headers.get("x-user-id");
    }

    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const businesses = await db.business.findMany({
      where: { ownerId: userId },
      select: {
        id: true,
        name: true,
        slug: true,
        category: true,
        status: true,
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ businesses });
  } catch (error) {
    console.error("Error fetching user businesses:", error);
    return NextResponse.json({ error: "Failed to fetch businesses" }, { status: 500 });
  }
}
```

This endpoint returns the current user's businesses so the dashboard can determine which business to manage services for.
  </action>
  <verify>Test endpoint: `curl http://localhost:3000/api/businesses/my` with mock headers should return businesses array.</verify>
  <done>/api/businesses/my endpoint exists and returns user's businesses</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` completes without errors
- [ ] /dashboard/services page loads without localStorage calls
- [ ] Creating a service via modal persists to database
- [ ] Services list shows database services, not localStorage
- [ ] Edit/Delete operations work correctly
</verification>

<success_criteria>
- Dashboard services page no longer uses localStorage
- All CRUD operations go through /api/businesses/[id]/services
- Loading and error states display appropriately
- Business owner can manage services for their business
- Categories are derived from service.category field
</success_criteria>

<output>
After completion, create `.planning/phases/01-booking-foundation/01-04-SUMMARY.md`
</output>
