---
phase: 01.1-web-scraping-revamp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/scraper/validation.ts
  - app/api/admin/scraped-businesses/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Scraped businesses can be validated as likely real businesses"
    - "Approved businesses include photos in the Business record"
    - "Approved businesses include tags in the Business record"
    - "Approved businesses include hours and metadata"
  artifacts:
    - path: "lib/scraper/validation.ts"
      provides: "Business validation logic with confidence scoring"
      exports: ["validateBusinessEntry", "ValidationResult"]
      min_lines: 80
    - path: "app/api/admin/scraped-businesses/[id]/route.ts"
      provides: "Complete approval transfer with photos, tags, hours"
      contains: "BusinessPhoto.createMany"
  key_links:
    - from: "lib/scraper/validation.ts"
      to: "ScrapedBusiness model"
      via: "ValidationResult type using ScrapedBusiness fields"
      pattern: "scraped\\.(name|address|phone)"
    - from: "app/api/admin/scraped-businesses/[id]/route.ts"
      to: "prisma.businessPhoto"
      via: "createMany for photo transfer"
      pattern: "db\\.businessPhoto\\.createMany"
---

<objective>
Create business validation module and fix the approval-to-business data transfer to ensure complete field mapping.

Purpose: Currently scraped businesses have no validation (spam, residential addresses pass through) and approval loses metadata (photos, tags, hours not transferred). This plan adds validation logic and fixes the data transfer.

Output:
- `lib/scraper/validation.ts` - Business validation with confidence scoring
- Enhanced PUT handler that transfers all metadata fields on approval
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-web-scraping-revamp/01.1-RESEARCH.md

# Key files to reference
@lib/scraper/types.ts
@lib/scraper/utils.ts
@app/api/admin/scraped-businesses/[id]/route.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create business validation module</name>
  <files>lib/scraper/validation.ts</files>
  <action>
Create `lib/scraper/validation.ts` with multi-signal business validation:

1. Define types:
```typescript
export interface ValidationResult {
  isLikelyBusiness: boolean;
  confidence: number;  // 0-100
  signals: ValidationSignal[];
  flags: string[];  // negative indicators found
}

export interface ValidationSignal {
  type: 'positive' | 'negative';
  signal: string;
  weight: number;
  context?: string;
}
```

2. Implement `validateBusinessEntry(scraped: ScrapedBusiness): ValidationResult`:

**Positive signals (add to score starting from base 50):**
- Valid phone format (US 10-digit): +20 points
- Has website URL (valid URL): +15 points
- Has street address (not just city): +20 points
- Business name pattern (contains Inc, LLC, Restaurant, Cafe, Market, Masjid, Mosque, etc.): +10 points
- Has description: +5 points
- Has email: +5 points

**Negative signals (subtract from score):**
- Residential address indicators (Apt, Unit without Suite 100+, Basement, Garage): -30 points
- Spam indicators in name/description (work from home, earn money, click here, limited time): -40 points
- Generic name (just "Business" or single common word): -15 points
- Missing address: -20 points
- Missing phone AND website: -15 points

3. Helper functions to implement:
- `containsResidentialIndicators(address: string): boolean`
- `containsSpamIndicators(name: string, description?: string): boolean`
- `hasBusinessNamePattern(name: string): boolean`
- `isGenericName(name: string): boolean`
- `isValidPhoneFormat(phone: string): boolean`
- `isValidUrl(url: string): boolean`

4. Return `isLikelyBusiness: true` if final score >= 60

Use patterns from research:
```typescript
// Residential patterns
const residential = [
  /\bapt\.?\s*#?\s*\d+/i,
  /\bunit\s*#?\s*\d+/i,
  /\b(suite|ste)\.?\s*(?!\d{3})\d{1,2}\b/i,  // Suite 1-99, not Suite 100+
  /\bfloor\s*\d+/i,
  /\bbasement\b/i,
  /\bgarage\b/i,
];

// Business name patterns
const businessIndicators = [
  /\b(inc|llc|corp|ltd|co|company)\b/i,
  /\b(restaurant|cafe|grill|kitchen|market|grocery|store|shop|salon|center)\b/i,
  /\b(services|solutions|consulting|agency)\b/i,
  /\bmasjid\b/i,
  /\bmosque\b/i,
];
```

Export the validation function and types.
  </action>
  <verify>
Run TypeScript compilation: `npx tsc --noEmit lib/scraper/validation.ts`
Verify exports: `grep -E "^export (function|interface)" lib/scraper/validation.ts`
  </verify>
  <done>
- validation.ts exists with validateBusinessEntry function
- ValidationResult and ValidationSignal types exported
- At least 6 positive signal checks implemented
- At least 4 negative signal checks implemented
- Score calculation returns 0-100 range with isLikelyBusiness threshold at 60
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance approval transfer with complete metadata</name>
  <files>app/api/admin/scraped-businesses/[id]/route.ts</files>
  <action>
Enhance the PUT handler in `app/api/admin/scraped-businesses/[id]/route.ts` to transfer ALL metadata when approving a scraped business:

1. Add import at top:
```typescript
import { BusinessTag } from "@prisma/client";
```

2. In the `if (claimStatus === "APPROVED")` block, replace the existing business creation with complete transfer:

```typescript
if (claimStatus === "APPROVED") {
  const scraped = await db.scrapedBusiness.findUnique({
    where: { id: businessId },
  });

  if (scraped) {
    // Parse metadata (stored as Json in ScrapedBusiness)
    const metadata = (scraped.metadata || {}) as {
      photos?: Array<{ url: string; caption?: string; type?: string }>;
      tags?: string[];
      hours?: Record<string, string>;
      priceRange?: string;
      serviceList?: string[];
      confidence?: number;
      source?: string;
    };

    // Generate unique slug
    const baseSlug = scraped.name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/^-|-$/g, "");
    const existingSlugs = await db.business.findMany({
      where: { slug: { startsWith: baseSlug } },
      select: { slug: true },
    });
    const slug = existingSlugs.length === 0
      ? baseSlug
      : `${baseSlug}-${existingSlugs.length + 1}`;

    // Create business with all fields
    const newBusiness = await db.business.create({
      data: {
        name: scraped.name,
        slug,
        description: scraped.description || `${scraped.name} in ${scraped.city}`,
        category: scraped.category,
        address: scraped.address,
        city: scraped.city,
        state: scraped.state,
        zipCode: scraped.zipCode,
        latitude: scraped.latitude || 37.5485,
        longitude: scraped.longitude || -121.9886,
        phone: scraped.phone || "",
        email: scraped.email,
        website: scraped.website,

        // NEW: Transfer additional metadata
        hours: metadata.hours || null,
        priceRange: metadata.priceRange as any || null,
        serviceList: metadata.serviceList || [],

        ownerId: "system",
        status: "PUBLISHED",
        verificationStatus: "UNVERIFIED",
        isScraped: true,
        scrapedBusinessId: scraped.id,
        scrapedFrom: metadata.source || scraped.sourceUrl,
        scrapedAt: scraped.scrapedAt,
        confidenceScore: metadata.confidence || null,
      },
    });

    // Transfer photos if available
    if (metadata.photos && metadata.photos.length > 0) {
      const validPhotos = metadata.photos.filter((photo) => {
        try {
          new URL(photo.url);
          return true;
        } catch {
          return false;
        }
      });

      if (validPhotos.length > 0) {
        await db.businessPhoto.createMany({
          data: validPhotos.map((photo, index) => ({
            businessId: newBusiness.id,
            url: photo.url,
            caption: photo.caption || null,
            type: photo.type || "general",
            order: index,
            isApproved: true,
          })),
        });
      }
    }

    // Transfer tags if available
    if (metadata.tags && metadata.tags.length > 0) {
      const validTags = metadata.tags.filter((tag) =>
        Object.values(BusinessTag).includes(tag as BusinessTag)
      );

      if (validTags.length > 0) {
        await db.businessTagRelation.createMany({
          data: validTags.map((tag) => ({
            businessId: newBusiness.id,
            tag: tag as BusinessTag,
          })),
          skipDuplicates: true,
        });
      }
    }

    return NextResponse.json({
      message: "Business approved and created",
      business: newBusiness,
      scrapedBusiness: updatedBusiness,
      photosTransferred: metadata.photos?.length || 0,
      tagsTransferred: metadata.tags?.length || 0,
    });
  }
}
```

3. Ensure the response includes transfer counts for debugging.

4. Handle edge cases:
- Invalid photo URLs are filtered out
- Invalid tag names are filtered out
- Missing metadata fields default to null/empty
- Slug collision handled with suffix
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit app/api/admin/scraped-businesses/[id]/route.ts`
Verify photo transfer code exists: `grep -n "businessPhoto.createMany" app/api/admin/scraped-businesses/[id]/route.ts`
Verify tag transfer code exists: `grep -n "businessTagRelation.createMany" app/api/admin/scraped-businesses/[id]/route.ts`
  </verify>
  <done>
- PUT handler transfers metadata.photos to BusinessPhoto table
- PUT handler transfers metadata.tags to BusinessTagRelation table
- PUT handler transfers metadata.hours to Business.hours
- Response includes photosTransferred and tagsTransferred counts
- Invalid URLs/tags are filtered out safely
- Slug generation handles collisions
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors:
   ```bash
   npx tsc --noEmit
   ```

2. Validation module exports correct functions:
   ```bash
   grep -E "^export" lib/scraper/validation.ts
   ```

3. Approval handler includes photo/tag transfer:
   ```bash
   grep -A5 "businessPhoto.createMany" app/api/admin/scraped-businesses/[id]/route.ts
   grep -A5 "businessTagRelation.createMany" app/api/admin/scraped-businesses/[id]/route.ts
   ```
</verification>

<success_criteria>
- [ ] lib/scraper/validation.ts exists with validateBusinessEntry function
- [ ] Validation returns confidence score 0-100 with positive/negative signals
- [ ] Approval handler transfers photos to BusinessPhoto table
- [ ] Approval handler transfers tags to BusinessTagRelation table
- [ ] Approval handler transfers hours to Business.hours
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-web-scraping-revamp/01.1-01-SUMMARY.md`
</output>
