---
phase: 02-production-auth-flows
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - app/api/auth/verify-email/route.ts
  - app/api/auth/reset-password/route.ts
  - app/api/auth/resend-verification/route.ts
  - app/api/auth/register/route.ts
  - prisma/schema.prisma
  - app/verify-email/page.tsx
  - app/reset-password/page.tsx
  - app/login/page.tsx
  - app/register/page.tsx
autonomous: true

must_haves:
  truths:
    - "User is auto-signed in after email verification"
    - "User is auto-signed in after password reset"
    - "User is redirected to home after verification"
    - "User is redirected to home after password reset"
    - "Resend verification has 1-minute cooldown"
  artifacts:
    - path: "app/api/auth/verify-email/route.ts"
      provides: "Returns auto-login token on success"
      contains: "autoLoginToken"
    - path: "app/api/auth/reset-password/route.ts"
      provides: "Returns email on success for auto sign-in"
      contains: "email:"
    - path: "prisma/schema.prisma"
      provides: "lastVerificationEmailSent and autoLoginToken fields on User"
      contains: "lastVerificationEmailSent"
  key_links:
    - from: "app/verify-email/page.tsx"
      to: "next-auth/react signIn"
      via: "signIn credentials with autoLoginToken"
      pattern: "signIn.*credentials"
    - from: "app/reset-password/page.tsx"
      to: "next-auth/react signIn"
      via: "signIn credentials after reset"
      pattern: "signIn.*credentials"
---

<objective>
Add auto sign-in after verification/reset and enforce resend cooldown.

Purpose: Per CONTEXT.md decisions, users should be automatically signed in after proving email ownership (verification) or setting a new password (reset). This reduces friction. The 1-minute cooldown prevents email spam.
Output: Modified API routes and frontend pages that auto-sign-in users and enforce rate limiting.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-production-auth-flows/02-CONTEXT.md
@.planning/phases/02-production-auth-flows/02-RESEARCH.md
@.planning/phases/02-production-auth-flows/02-01-SUMMARY.md

# Files to modify
@app/api/auth/verify-email/route.ts
@app/api/auth/reset-password/route.ts
@app/api/auth/resend-verification/route.ts
@app/api/auth/register/route.ts
@prisma/schema.prisma
@app/verify-email/page.tsx
@app/reset-password/page.tsx
@app/login/page.tsx
@app/register/page.tsx

# Auth config for reference
@lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-login token system and rate limiting field</name>
  <files>
    prisma/schema.prisma
    app/api/auth/register/route.ts
    app/api/auth/verify-email/route.ts
    app/api/auth/reset-password/route.ts
    app/api/auth/resend-verification/route.ts
    lib/auth.ts
  </files>
  <action>
**Goal:** Enable true auto sign-in after email verification using a secure token-based approach.

**1. Add fields to User model in `prisma/schema.prisma`:**
```prisma
// Add after passwordResetExpires field:
lastVerificationEmailSent DateTime?
autoLoginToken            String?   @unique
autoLoginTokenExpires     DateTime?
```

**2. Run `npx prisma db push` to sync schema.**

**3. Update `app/api/auth/register/route.ts`:**
After creating the user and sending verification email, generate an auto-login token:
```typescript
import crypto from "crypto";

// After user creation, generate auto-login token (valid for 24h to match verification link)
const autoLoginToken = crypto.randomBytes(32).toString("hex");
const autoLoginTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

await db.user.update({
  where: { id: user.id },
  data: {
    autoLoginToken,
    autoLoginTokenExpires,
  },
});

// Return the token to the frontend (will be stored in sessionStorage)
return NextResponse.json({
  message: "Registration successful. Please check your email to verify your account.",
  autoLoginToken, // Frontend stores this for post-verification auto-login
});
```

**4. Update `app/api/auth/verify-email/route.ts` POST handler:**
After successful verification, check for and use the auto-login token:
```typescript
// After marking email as verified:
// Clear the verification token
await db.user.update({
  where: { id: user.id },
  data: {
    emailVerified: new Date(),
    emailVerificationToken: null,
    emailVerificationExpires: null,
  },
});

// Return user email for auto sign-in
return NextResponse.json({
  message: "Email verified successfully",
  email: user.email,
  canAutoLogin: !!user.autoLoginToken && user.autoLoginTokenExpires && user.autoLoginTokenExpires > new Date(),
});
```

**5. Add a new API endpoint for auto-login token verification in `lib/auth.ts`:**
Add support for auto-login token in the Credentials provider. Modify the authorize function to accept an `autoLoginToken` credential as an alternative to password:

```typescript
// In credentials definition, add:
autoLoginToken: { label: "Auto Login Token", type: "text" },

// In authorize function, add this check BEFORE password validation:
// Check for auto-login token (used after email verification)
if (credentials.autoLoginToken && !credentials.password) {
  const autoLoginToken = credentials.autoLoginToken as string;

  // Find user by email AND valid auto-login token
  const userWithToken = await prisma.user.findFirst({
    where: {
      email: credentials.email as string,
      autoLoginToken: autoLoginToken,
      autoLoginTokenExpires: { gt: new Date() },
      emailVerified: { not: null }, // Must be verified
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      image: true,
      isBanned: true,
      banReason: true,
    },
  });

  if (!userWithToken) {
    return null; // Invalid or expired token
  }

  if (userWithToken.isBanned) {
    throw new Error(`Your account has been suspended. ${userWithToken.banReason || ""}`);
  }

  // Clear the auto-login token (one-time use)
  await prisma.user.update({
    where: { id: userWithToken.id },
    data: {
      autoLoginToken: null,
      autoLoginTokenExpires: null,
      lastLoginAt: new Date(),
      lastActiveAt: new Date(),
    },
  });

  // Log successful login
  await prisma.activityLog.create({
    data: {
      userId: userWithToken.id,
      action: "LOGIN",
      entityType: "User",
      entityId: userWithToken.id,
      details: { success: true, method: "auto_login_after_verification" },
    },
  });

  return {
    id: userWithToken.id,
    email: userWithToken.email,
    name: userWithToken.name,
    role: userWithToken.role,
    image: userWithToken.image,
  };
}

// Continue with existing password validation...
```

**6. Update `app/api/auth/reset-password/route.ts` POST handler:**
After successful password reset, return the user's email:
```typescript
return NextResponse.json({
  message: "Password reset successfully",
  email: user.email,
});
```

**7. Update `app/api/auth/resend-verification/route.ts`:**
Add cooldown check after finding the user:
```typescript
const COOLDOWN_MS = 60 * 1000; // 1 minute

if (user.lastVerificationEmailSent) {
  const timeSinceLastEmail = Date.now() - user.lastVerificationEmailSent.getTime();
  if (timeSinceLastEmail < COOLDOWN_MS) {
    const secondsRemaining = Math.ceil((COOLDOWN_MS - timeSinceLastEmail) / 1000);
    return NextResponse.json(
      { error: `Please wait ${secondsRemaining} seconds before requesting another email` },
      { status: 429 }
    );
  }
}

// When updating user with new token, also set lastVerificationEmailSent:
await db.user.update({
  where: { id: user.id },
  data: {
    emailVerificationToken,
    emailVerificationExpires,
    lastVerificationEmailSent: new Date(),
  },
});
```
  </action>
  <verify>
- `npx prisma validate` passes
- `npm run build` passes
- Register API returns autoLoginToken in response
- Verify-email API returns canAutoLogin flag
  </verify>
  <done>
Database has auto-login token fields, register returns token, verify-email supports token-based auth, APIs return email on success, resend has 1-minute cooldown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auto sign-in on register, verify-email, and reset-password pages</name>
  <files>
    app/register/page.tsx
    app/verify-email/page.tsx
    app/reset-password/page.tsx
    app/login/page.tsx
  </files>
  <action>
**Goal:** True auto sign-in after email verification AND password reset, redirecting to home page.

**1. Update `app/register/page.tsx` (production mode section):**
After successful registration, store the auto-login token:
```typescript
// In production mode, after successful response:
const data = await response.json();

if (!response.ok) {
  setError(data.error || "Registration failed");
  return;
}

// Store auto-login token for post-verification auto sign-in
if (data.autoLoginToken) {
  sessionStorage.setItem("pendingVerificationEmail", formData.email);
  sessionStorage.setItem("autoLoginToken", data.autoLoginToken);
}

router.push("/login?registered=true");
```

**2. Update `app/verify-email/page.tsx`:**
Implement true auto sign-in after verification:
```typescript
import { signIn } from "next-auth/react";

// On successful verification:
const handleVerificationSuccess = async (email: string, canAutoLogin: boolean) => {
  setStatus("success");

  // Check for stored auto-login token
  const storedEmail = sessionStorage.getItem("pendingVerificationEmail");
  const autoLoginToken = sessionStorage.getItem("autoLoginToken");

  if (canAutoLogin && autoLoginToken && storedEmail === email) {
    setStatus("signing-in");
    setMessage("Email verified! Signing you in...");

    // Clear stored tokens
    sessionStorage.removeItem("pendingVerificationEmail");
    sessionStorage.removeItem("autoLoginToken");

    try {
      const result = await signIn("credentials", {
        email: email,
        autoLoginToken: autoLoginToken,
        redirect: false,
      });

      if (result?.ok) {
        // Success! Redirect to home
        router.push("/");
        return;
      }
      // If auto-login fails, fall through to login redirect
    } catch (error) {
      console.error("Auto sign-in failed:", error);
    }
  }

  // Fallback: redirect to login with success message
  setMessage("Email verified successfully!");
  setTimeout(() => {
    router.push("/login?verified=true");
  }, 2000);
};

// States should include: "verifying" | "success" | "signing-in" | "error"
// Update the success case in useEffect to call handleVerificationSuccess:
if (response.ok) {
  const data = await response.json();
  await handleVerificationSuccess(data.email, data.canAutoLogin);
}
```

**3. Update `app/reset-password/page.tsx`:**
Implement true auto sign-in after password reset (this is straightforward because we have the password):
```typescript
import { signIn } from "next-auth/react";

// On successful password reset:
// We have: email from API response, password from form
const handleResetSuccess = async (email: string, password: string) => {
  setStatus("signing-in");
  setMessage("Password reset! Signing you in...");

  try {
    const result = await signIn("credentials", {
      email: email,
      password: password,
      redirect: false,
    });

    if (result?.ok) {
      // Success! Redirect to home
      router.push("/");
      return;
    }
  } catch (error) {
    console.error("Auto sign-in failed:", error);
  }

  // Fallback: redirect to login
  setStatus("success");
  setMessage("Password reset successfully!");
  setTimeout(() => {
    router.push("/login?reset=true");
  }, 2000);
};

// Call after successful POST to reset-password API:
const data = await response.json();
await handleResetSuccess(data.email, password); // password from form state
```

**4. Update `app/login/page.tsx`:**
Add success banners for verified and reset states (fallback cases):
```typescript
// At top of component, check for query params:
const searchParams = useSearchParams();
const verified = searchParams.get("verified") === "true";
const reset = searchParams.get("reset") === "true";
const registered = searchParams.get("registered") === "true";

// In the JSX, before the form, show success banners:
{verified && (
  <div className="bg-green-50 text-green-600 p-3 rounded-md text-sm flex items-center gap-2 mb-4">
    <CheckCircle className="h-4 w-4" />
    Email verified successfully! Please sign in.
  </div>
)}

{reset && (
  <div className="bg-green-50 text-green-600 p-3 rounded-md text-sm flex items-center gap-2 mb-4">
    <CheckCircle className="h-4 w-4" />
    Password reset successfully! Sign in with your new password.
  </div>
)}

{registered && (
  <div className="bg-blue-50 text-blue-600 p-3 rounded-md text-sm flex items-center gap-2 mb-4">
    <Mail className="h-4 w-4" />
    Registration successful! Please check your email to verify your account.
  </div>
)}
```
Also wrap in Suspense for SSR compatibility with useSearchParams.
  </action>
  <verify>
- `npm run build` passes
- Register stores autoLoginToken in sessionStorage
- Verify-email page attempts auto sign-in with stored token
- Reset-password page auto-signs in with new password
- On success, both pages redirect to "/" (home)
- Login page shows success banners as fallback
  </verify>
  <done>
Users are auto-signed in after email verification (using token) and password reset (using new password). Both redirect to home page on success. Login page shows success banners as fallback for edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle resend cooldown in verify-email page UI</name>
  <files>app/verify-email/page.tsx</files>
  <action>
Update the resend verification form in `app/verify-email/page.tsx`:

1. After calling resend API:
   - If 429 response, parse error message and show cooldown countdown
   - Display: "Please wait {seconds} seconds before requesting another email"
   - Disable the resend button during cooldown
   - Use setInterval to count down and re-enable button

2. Add state for cooldown:
   ```typescript
   const [cooldownSeconds, setCooldownSeconds] = useState(0);
   ```

3. When receiving 429:
   - Parse seconds from error message (regex: /wait (\d+) seconds/)
   - Set cooldownSeconds state
   - Start interval to decrement every second
   - When reaches 0, re-enable button

4. Button should show:
   - Normal: "Resend verification email"
   - Cooldown: "Resend in {seconds}s"
   - Loading: "Sending..."
   - Success: "Email sent! Check your inbox"
  </action>
  <verify>
- `npm run build` passes
- Clicking resend twice shows cooldown message
- Button shows countdown timer during cooldown
- Button re-enables after cooldown expires
  </verify>
  <done>
Verify-email page shows cooldown timer when rate limited, prevents spam clicking.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should pass with no errors
2. Run `npx prisma validate` - schema is valid
3. Test password reset flow:
   - Request reset email (or use test token)
   - Set new password on reset page
   - User should be auto-signed in and redirected to home "/"
4. Test verification flow:
   - Register new user in production mode
   - Check sessionStorage has autoLoginToken
   - Click verification link
   - User should be auto-signed in and redirected to home "/"
5. Test resend cooldown:
   - On verify-email page with invalid token
   - Enter email and click resend
   - Immediately click resend again
   - Should see cooldown message and disabled button
</verification>

<success_criteria>
- [ ] Database has autoLoginToken and lastVerificationEmailSent fields
- [ ] Register API returns autoLoginToken
- [ ] Auth config supports autoLoginToken credential
- [ ] Email verification auto-signs in user and redirects to home "/"
- [ ] Password reset auto-signs in user and redirects to home "/"
- [ ] Login page shows success banners for verified/reset params (fallback)
- [ ] Resend verification has 1-minute cooldown enforced in API
- [ ] Verify-email page shows cooldown UI when rate limited
- [ ] Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-production-auth-flows/02-02-SUMMARY.md`
</output>
