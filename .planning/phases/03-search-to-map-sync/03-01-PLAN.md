---
phase: 03-search-to-map-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/businesses/route.ts
  - app/layout.tsx
  - hooks/useMapSearch.ts
autonomous: true

must_haves:
  truths:
    - "API accepts ne_lat, ne_lng, sw_lat, sw_lng query params"
    - "API returns businesses within specified bounding box"
    - "useMapSearch hook reads filters from URL params"
    - "useMapSearch hook fetches data via React Query"
    - "URL changes trigger data refetch automatically"
  artifacts:
    - path: "app/api/businesses/route.ts"
      provides: "Bounds-based filtering"
      contains: "ne_lat && ne_lng && sw_lat && sw_lng"
    - path: "hooks/useMapSearch.ts"
      provides: "Shared state for map-search sync"
      exports: ["useMapSearch"]
    - path: "app/layout.tsx"
      provides: "QueryClientProvider wrapper"
      contains: "QueryClientProvider"
  key_links:
    - from: "hooks/useMapSearch.ts"
      to: "/api/businesses"
      via: "React Query fetch"
      pattern: "fetch.*api/businesses"
    - from: "hooks/useMapSearch.ts"
      to: "next/navigation"
      via: "useSearchParams"
      pattern: "useSearchParams"
---

<objective>
Implement API bounds filtering and useMapSearch hook foundation

Purpose: Enable viewport-based business filtering and establish URL-first state management pattern for search-map synchronization. This creates the foundation that Plan 02 will consume.

Output:
- API route extended with bounds parameters (ne_lat, ne_lng, sw_lat, sw_lng)
- QueryClientProvider added to app layout
- useMapSearch hook providing shared state via URL params + React Query
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-to-map-sync/03-RESEARCH.md

# Current implementations
@app/api/businesses/route.ts
@app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend API with bounds filtering</name>
  <files>app/api/businesses/route.ts</files>
  <action>
Add viewport bounds parameters to the GET handler:

1. Parse new query params: ne_lat, ne_lng, sw_lat, sw_lng
2. Add bounds-based filtering AFTER existing where clause construction:
   - If all 4 bounds params present, add latitude/longitude constraints:
     ```typescript
     if (ne_lat && ne_lng && sw_lat && sw_lng) {
       where.latitude = {
         gte: parseFloat(sw_lat),
         lte: parseFloat(ne_lat),
       };
       where.longitude = {
         gte: parseFloat(sw_lng),
         lte: parseFloat(ne_lng),
       };
     }
     ```
3. Bounds filtering takes precedence over radius filtering (if bounds provided, skip radius filter)
4. Keep existing lat/lng/radius filtering as fallback when bounds not provided

Do NOT change existing radius-based filtering - it remains the default when bounds not provided.
  </action>
  <verify>
Test via curl:
```bash
# Bounds query - should return businesses within box
curl "http://localhost:3000/api/businesses?ne_lat=37.6&ne_lng=-121.9&sw_lat=37.5&sw_lng=-122.0&status=PUBLISHED"

# Verify existing radius query still works
curl "http://localhost:3000/api/businesses?lat=37.5485&lng=-121.9886&radius=25&status=PUBLISHED"
```
  </verify>
  <done>
API accepts bounds params and returns businesses within bounding box. Existing radius queries continue to work unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add QueryClientProvider to app layout</name>
  <files>app/layout.tsx</files>
  <action>
Add React Query provider:

1. Create QueryClient with sensible defaults:
   - staleTime: 30000 (30 seconds - prevents constant refetches)
   - refetchOnWindowFocus: false (better UX for map interactions)

2. Wrap children with QueryClientProvider inside existing providers:
   - Keep existing provider nesting (LanguageProvider > MockSessionProvider)
   - Add QueryClientProvider at appropriate level (inside MockSessionProvider)

3. Create QueryClient using useState pattern to avoid recreation:
   ```typescript
   'use client' // Add if not present
   const [queryClient] = useState(() => new QueryClient({...}))
   ```

Note: The layout imports need to add QueryClient, QueryClientProvider from @tanstack/react-query.
Since layout.tsx is currently a server component, you need to either:
- Make layout.tsx a client component (add 'use client'), OR
- Create a separate Providers component that wraps QueryClientProvider

RECOMMENDED: Create a new QueryProvider component that is a client component, then import it into layout. This keeps layout as server component.
  </action>
  <verify>
```bash
npm run build
# Should compile without errors

# Start dev server and check React Query devtools work (if installed)
npm run dev
# Visit /search - should not see "no QueryClient set" errors in console
```
  </verify>
  <done>
QueryClientProvider wraps the app. No console errors about missing QueryClient when visiting pages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useMapSearch hook</name>
  <files>hooks/useMapSearch.ts</files>
  <action>
Create the central hook for search-map synchronization following the pattern in 03-RESEARCH.md:

1. Create hooks/useMapSearch.ts (new file)

2. Interface for filters:
```typescript
export interface MapSearchFilters {
  search: string;
  category: string;
  tags: string[];
  distance: string;
  sort: string;
  priceRange: string;
  minRating: string;
  // Bounds override lat/lng/distance when present
  ne_lat: string | null;
  ne_lng: string | null;
  sw_lat: string | null;
  sw_lng: string | null;
}
```

3. Hook implementation:
- Read filters from URL via useSearchParams
- Provide setFilters function that updates URL (router.replace with scroll: false)
- Use React Query useQuery with filters in queryKey
- Query enabled only when userLocation exists OR bounds params present
- Return { filters, setFilters, businesses, isLoading, error }

4. Handle array params (tags) properly:
- Parse: `searchParams.get('tags')?.split(',').filter(Boolean) || []`
- Set: Join with comma, delete if empty

5. Fetch logic:
- If bounds params present: use ne_lat, ne_lng, sw_lat, sw_lng
- Else if userLocation provided: use lat, lng, radius
- Always include status=PUBLISHED

6. Export Business interface matching existing pattern in search/page.tsx

IMPORTANT: This hook must be a client component ('use client' directive).
  </action>
  <verify>
```bash
# Verify TypeScript compiles
npx tsc --noEmit

# Check hook can be imported
grep -r "useMapSearch" hooks/
```

Manual verification in next task (Plan 02) when hook is actually used.
  </verify>
  <done>
hooks/useMapSearch.ts exists, exports useMapSearch hook and MapSearchFilters interface. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. API bounds test:
```bash
curl "http://localhost:3000/api/businesses?ne_lat=37.6&ne_lng=-121.9&sw_lat=37.5&sw_lng=-122.0&status=PUBLISHED" | jq 'length'
```
Should return count of businesses in that box (may be 0 if no businesses in test bounds - adjust bounds to match your data).

2. TypeScript:
```bash
npx tsc --noEmit
```
No errors.

3. Build:
```bash
npm run build
```
Completes successfully.
</verification>

<success_criteria>
- [ ] API accepts ne_lat, ne_lng, sw_lat, sw_lng params and filters correctly
- [ ] Existing radius-based filtering continues to work
- [ ] QueryClientProvider wraps the application
- [ ] useMapSearch hook exists and exports correct interface
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-to-map-sync/03-01-SUMMARY.md`
</output>
