---
phase: 03-security-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - lib/auth.ts
  - lib/email.ts
  - app/api/auth/link-account/route.ts
  - app/(auth)/link-account/page.tsx
autonomous: true

must_haves:
  truths:
    - "OAuth sign-in with existing email prompts for account linking verification"
    - "User receives email to confirm account linking"
    - "After email verification, OAuth account is linked to existing account"
    - "Both sign-in methods work after linking (OAuth and email/password)"
    - "Invalid/expired link tokens show clear error"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "PendingAccountLink model for storing pending OAuth links"
      contains: "model PendingAccountLink"
    - path: "lib/auth.ts"
      provides: "Safe OAuth linking flow in signIn callback"
      exports: ["handlers", "auth", "signIn", "signOut"]
    - path: "app/api/auth/link-account/route.ts"
      provides: "API for verifying link tokens"
      exports: ["GET"]
    - path: "app/(auth)/link-account/page.tsx"
      provides: "Frontend page for account linking flow"
      min_lines: 50
  key_links:
    - from: "lib/auth.ts"
      to: "prisma.pendingAccountLink"
      via: "signIn callback creates pending link"
      pattern: "pendingAccountLink\\.create"
    - from: "app/api/auth/link-account/route.ts"
      to: "prisma.account.create"
      via: "GET handler completes linking"
      pattern: "account\\.create"
    - from: "lib/email.ts"
      to: "sendAccountLinkEmail"
      via: "new email function"
      pattern: "sendAccountLinkEmail"
---

<objective>
Replace dangerous OAuth account linking with verified linking flow.

Purpose: Prevent account takeover via OAuth email matching by requiring email verification before linking accounts. Per SEC-01 requirement.

Output: Safe OAuth linking with email verification, PendingAccountLink model, link-account API and page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-fixes/03-CONTEXT.md
@.planning/phases/03-security-fixes/03-RESEARCH.md
@lib/auth.ts
@lib/email.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PendingAccountLink model and email function</name>
  <files>prisma/schema.prisma, lib/email.ts</files>
  <action>
1. Add PendingAccountLink model to `prisma/schema.prisma`:
   ```prisma
   model PendingAccountLink {
     id                String   @id @default(cuid())
     userId            String
     provider          String
     providerAccountId String
     token             String   @unique
     expires           DateTime
     createdAt         DateTime @default(now())

     user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

     @@index([userId])
     @@index([token])
   }
   ```

2. Add relation to User model:
   ```prisma
   model User {
     // ... existing fields
     pendingAccountLinks PendingAccountLink[]
   }
   ```

3. Run `npx prisma db push` to update database (or generate migration)

4. Add `sendAccountLinkEmail` function to `lib/email.ts`:
   ```typescript
   export async function sendAccountLinkEmail(
     email: string,
     token: string,
     provider: string
   ): Promise<EmailResult> {
     const linkUrl = `${APP_URL}/api/auth/link-account?token=${token}`;
     const providerName = provider.charAt(0).toUpperCase() + provider.slice(1);

     return sendEmail({
       to: email,
       subject: `Link your ${providerName} account - Manaakhah`,
       html: `
         <h2>Link Your ${providerName} Account</h2>
         <p>Someone tried to sign in with ${providerName} using your email address.</p>
         <p>If this was you, click the link below to connect your ${providerName} account:</p>
         <p><a href="${linkUrl}">Link ${providerName} Account</a></p>
         <p>This link expires in 24 hours.</p>
         <p>If you didn't request this, you can safely ignore this email.</p>
       `,
     });
   }
   ```
  </action>
  <verify>
- `npx prisma db push` completes without errors
- `npx prisma generate` produces client with PendingAccountLink type
- TypeScript shows sendAccountLinkEmail in lib/email exports
  </verify>
  <done>
- PendingAccountLink model exists in schema
- User model has pendingAccountLinks relation
- sendAccountLinkEmail function exists in lib/email.ts
- Database schema updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify OAuth signIn callback for safe linking</name>
  <files>lib/auth.ts</files>
  <action>
1. Remove `allowDangerousEmailAccountLinking: true` from BOTH Google and Apple providers (lines ~31 and ~37)

2. Modify the signIn callback to handle email conflicts safely:
   ```typescript
   async signIn({ user, account, profile }) {
     // Handle OAuth sign-in (Google, Apple)
     if (account?.provider === "google" || account?.provider === "apple") {
       // Check if user exists
       const existingUser = await prisma.user.findUnique({
         where: { email: user.email! },
         include: { accounts: true },
       });

       // Check if banned
       if (existingUser?.isBanned) {
         return `/login?error=Your account has been suspended. ${existingUser.banReason || ""}`;
       }

       // If user exists but doesn't have this OAuth provider linked
       if (existingUser && !existingUser.accounts.some(a => a.provider === account.provider)) {
         // Create pending link token
         const token = crypto.randomBytes(32).toString("hex");
         const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

         await prisma.pendingAccountLink.create({
           data: {
             userId: existingUser.id,
             provider: account.provider,
             providerAccountId: account.providerAccountId,
             token,
             expires,
           },
         });

         // Send verification email
         const { sendAccountLinkEmail } = await import("@/lib/email");
         await sendAccountLinkEmail(user.email!, token, account.provider);

         // Redirect to link-account page (NOT an error, just a flow)
         return `/link-account?email=${encodeURIComponent(user.email!)}&provider=${account.provider}`;
       }

       // New user OR user already has this provider - allow normal flow
       if (!existingUser) {
         // New user via OAuth - create account
         await prisma.user.create({
           data: {
             email: user.email!,
             name: user.name,
             image: user.image,
             emailVerified: new Date(), // OAuth users are auto-verified
           },
         });
       } else {
         // Existing user with this provider already linked - just update timestamps
         await prisma.user.update({
           where: { id: existingUser.id },
           data: {
             lastLoginAt: new Date(),
             lastActiveAt: new Date(),
           },
         });
       }
     }
     return true;
   }
   ```

3. Add crypto import at top of file: `import crypto from "crypto";`

4. IMPORTANT: The existing user.upsert logic needs to be removed/modified since we now handle user creation explicitly in the signIn callback.
  </action>
  <verify>
- No `allowDangerousEmailAccountLinking` in lib/auth.ts
- OAuth sign-in with existing email redirects to /link-account page
- OAuth sign-in with new email creates user normally
- OAuth sign-in with already-linked provider works normally
  </verify>
  <done>
- allowDangerousEmailAccountLinking removed from both providers
- signIn callback creates PendingAccountLink for email conflicts
- Verification email sent for account linking
- New OAuth users created properly
- Existing linked users authenticated properly
  </done>
</task>

<task type="auto">
  <name>Task 3: Create link-account API and page</name>
  <files>app/api/auth/link-account/route.ts, app/(auth)/link-account/page.tsx</files>
  <action>
1. Create `app/api/auth/link-account/route.ts`:
   ```typescript
   import { NextResponse } from "next/server";
   import { prisma } from "@/lib/prisma";

   // GET /api/auth/link-account?token=xxx - Verify link and complete account linking
   export async function GET(req: Request) {
     const { searchParams } = new URL(req.url);
     const token = searchParams.get("token");

     if (!token) {
       return NextResponse.redirect(new URL("/link-account?error=missing_token", req.url));
     }

     try {
       const pendingLink = await prisma.pendingAccountLink.findUnique({
         where: { token },
         include: { user: true },
       });

       if (!pendingLink) {
         return NextResponse.redirect(new URL("/link-account?error=invalid_token", req.url));
       }

       if (pendingLink.expires < new Date()) {
         // Clean up expired token
         await prisma.pendingAccountLink.delete({ where: { id: pendingLink.id } });
         return NextResponse.redirect(new URL("/link-account?error=expired_token", req.url));
       }

       // Create the OAuth account link
       await prisma.account.create({
         data: {
           userId: pendingLink.userId,
           type: "oauth",
           provider: pendingLink.provider,
           providerAccountId: pendingLink.providerAccountId,
         },
       });

       // Clean up pending link
       await prisma.pendingAccountLink.delete({ where: { id: pendingLink.id } });

       // Update last login
       await prisma.user.update({
         where: { id: pendingLink.userId },
         data: {
           lastLoginAt: new Date(),
           lastActiveAt: new Date(),
         },
       });

       // Redirect to login with success message
       const providerName = pendingLink.provider.charAt(0).toUpperCase() + pendingLink.provider.slice(1);
       return NextResponse.redirect(
         new URL(`/login?success=account_linked&provider=${providerName}`, req.url)
       );
     } catch (error) {
       console.error("Account link error:", error);
       return NextResponse.redirect(new URL("/link-account?error=server_error", req.url));
     }
   }
   ```

2. Create `app/(auth)/link-account/page.tsx`:
   ```tsx
   "use client";

   import { useSearchParams } from "next/navigation";
   import Link from "next/link";
   import { Suspense } from "react";

   function LinkAccountContent() {
     const searchParams = useSearchParams();
     const email = searchParams.get("email");
     const provider = searchParams.get("provider");
     const error = searchParams.get("error");

     const providerName = provider
       ? provider.charAt(0).toUpperCase() + provider.slice(1)
       : "OAuth";

     const errorMessages: Record<string, string> = {
       missing_token: "The verification link is invalid.",
       invalid_token: "The verification link is invalid or has already been used.",
       expired_token: "The verification link has expired. Please try signing in again.",
       server_error: "Something went wrong. Please try again.",
     };

     if (error) {
       return (
         <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
           <div className="max-w-md w-full space-y-8 text-center">
             <div className="bg-red-50 border border-red-200 rounded-lg p-6">
               <h2 className="text-xl font-semibold text-red-800 mb-2">Link Failed</h2>
               <p className="text-red-600 mb-4">
                 {errorMessages[error] || "An unknown error occurred."}
               </p>
               <Link
                 href="/login"
                 className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-emerald-600 hover:bg-emerald-700"
               >
                 Back to Login
               </Link>
             </div>
           </div>
         </div>
       );
     }

     return (
       <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
         <div className="max-w-md w-full space-y-8 text-center">
           <div className="bg-blue-50 border border-blue-200 rounded-lg p-6">
             <h2 className="text-xl font-semibold text-blue-800 mb-2">
               Check Your Email
             </h2>
             <p className="text-blue-600 mb-4">
               An account with <strong>{email}</strong> already exists.
             </p>
             <p className="text-gray-600 mb-4">
               We've sent a verification email to confirm you want to link your{" "}
               <strong>{providerName}</strong> account. Click the link in the email
               to complete the process.
             </p>
             <p className="text-sm text-gray-500 mb-4">
               The link will expire in 24 hours.
             </p>
             <Link
               href="/login"
               className="inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50"
             >
               Back to Login
             </Link>
           </div>
         </div>
       </div>
     );
   }

   export default function LinkAccountPage() {
     return (
       <Suspense fallback={<div className="min-h-screen flex items-center justify-center">Loading...</div>}>
         <LinkAccountContent />
       </Suspense>
     );
   }
   ```

3. Update login page to show success message for account linking:
   In `app/(auth)/login/page.tsx`, add handling for `success=account_linked&provider=X` query param to show a success banner like "Your {provider} account has been linked. You can now sign in with either method."
  </action>
  <verify>
- Visiting /link-account?email=test@example.com&provider=google shows "check your email" message
- Visiting /api/auth/link-account?token=invalid redirects to /link-account?error=invalid_token
- After clicking valid link, redirects to /login?success=account_linked
  </verify>
  <done>
- /api/auth/link-account API route handles token verification and account linking
- /link-account page shows appropriate messages for pending/error states
- Login page shows success message after account linked
- Full flow: OAuth -> email conflict -> verify email -> account linked -> login
  </done>
</task>

</tasks>

<verification>
1. Test new user OAuth sign-in:
   - Sign in with Google using new email
   - Should create user and sign in normally

2. Test existing user OAuth sign-in (already linked):
   - Sign in with Google using email that already has Google linked
   - Should sign in normally

3. Test account linking flow:
   - Create user with email/password
   - Try to sign in with Google using same email
   - Should redirect to /link-account page
   - Check email for verification link
   - Click link - should redirect to /login with success message
   - Sign in with Google - should work now

4. Test error cases:
   - Visit /api/auth/link-account?token=invalid - error page
   - Wait >24h then click link - expired error
</verification>

<success_criteria>
- SEC-01 satisfied: allowDangerousEmailAccountLinking removed, replaced with verified linking flow
- OAuth email conflicts require email verification before linking
- Both authentication methods work after linking
- Clear user communication throughout flow
- No account takeover possible via OAuth email matching
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-fixes/03-02-SUMMARY.md`
</output>
