---
phase: 04-map-to-search-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/useMapSearch.ts
  - components/map/SearchThisAreaButton.tsx
  - components/map/MapLibreMap.tsx
  - app/search/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can pan or zoom the map and see a 'Search this area' button appear"
    - "Clicking 'Search this area' fetches businesses within current map bounds"
    - "URL updates with map bounds for shareable links"
    - "Existing results dim/fade while user explores to indicate staleness"
    - "No infinite loop occurs between map moves and search updates"
  artifacts:
    - path: "hooks/useMapSearch.ts"
      provides: "isStale state, searchBounds method, currentBounds tracking"
      exports: ["useMapSearch", "MapSearchFilters", "Business"]
    - path: "components/map/SearchThisAreaButton.tsx"
      provides: "Floating button component for map viewport search"
      exports: ["SearchThisAreaButton"]
    - path: "components/map/MapLibreMap.tsx"
      provides: "Map movement tracking via onMoveEnd"
      contains: "onMoveEnd"
    - path: "app/search/page.tsx"
      provides: "Stale results visual dimming"
      contains: "isStale"
  key_links:
    - from: "components/map/MapLibreMap.tsx"
      to: "components/map/SearchThisAreaButton.tsx"
      via: "Renders button when isStale is true"
      pattern: "isStale.*SearchThisAreaButton"
    - from: "components/map/SearchThisAreaButton.tsx"
      to: "hooks/useMapSearch.ts"
      via: "Calls setFilters with bounds on click"
      pattern: "setFilters.*ne_lat"
    - from: "hooks/useMapSearch.ts"
      to: "URL params"
      via: "Updates URL with bounds for shareable links"
      pattern: "router\\.replace"
---

<objective>
Implement bidirectional map-to-search sync with a "Search this area" button that appears when users pan/zoom the map.

Purpose: Users can explore the map freely and explicitly choose when to refresh search results based on the visible area, completing the bidirectional sync started in Phase 3.

Output: Extended useMapSearch hook with stale tracking, SearchThisAreaButton component, MapLibreMap with movement detection, and visual feedback for stale results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-map-to-search-sync/04-CONTEXT.md
@.planning/phases/04-map-to-search-sync/04-RESEARCH.md
@.planning/phases/03-search-to-map-sync/03-01-SUMMARY.md
@.planning/phases/03-search-to-map-sync/03-02-SUMMARY.md

# Key source files to understand before implementing
@hooks/useMapSearch.ts
@components/map/MapLibreMap.tsx
@app/search/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useMapSearch hook with stale tracking</name>
  <files>hooks/useMapSearch.ts</files>
  <action>
Extend the useMapSearch hook to support map-to-search sync:

1. Add new state and exports:
   - `currentBounds`: The bounds of the last successful search (from URL params)
   - `isStale`: Boolean indicating map has moved but results not refreshed
   - `setIsStale`: Function to update stale state (called by map component)

2. Add `searchBounds(bounds: MapBounds)` method that:
   - Calls setFilters with ne_lat, ne_lng, sw_lat, sw_lng (rounded to 6 decimal places)
   - Clears isStale state after successful update
   - Clears distance filter when searching by bounds (makes UX sense)

3. The isStale state should be:
   - Managed locally in the hook (useState)
   - Exposed via return object so components can read/set it
   - Set to false when filters change (via useEffect on filters)

4. Return the new properties from the hook: `isStale`, `setIsStale`, `searchBounds`, `currentBounds`

Important: Do NOT add debouncing to the hook. Movement debouncing happens in the map component via onMoveEnd event timing.

Reference existing patterns in the hook for setFilters URL update logic.
  </action>
  <verify>
- `grep -n "isStale" hooks/useMapSearch.ts` shows state and export
- `grep -n "searchBounds" hooks/useMapSearch.ts` shows method
- `grep -n "currentBounds" hooks/useMapSearch.ts` shows bounds tracking
- `npx tsc --noEmit` passes
  </verify>
  <done>
useMapSearch hook exports isStale, setIsStale, searchBounds, and currentBounds. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SearchThisAreaButton and wire to MapLibreMap</name>
  <files>components/map/SearchThisAreaButton.tsx, components/map/MapLibreMap.tsx</files>
  <action>
Create SearchThisAreaButton component and integrate it with MapLibreMap:

**SearchThisAreaButton.tsx (NEW):**
1. Create a button component that:
   - Accepts `onClick` and `isLoading` props
   - Uses site's existing Button component from @/components/ui/button
   - Shows "Search this area" text with Loader2 spinner when loading
   - Positioned absolutely at bottom center of map (the parent handles positioning)

2. Styling:
   - Use standard Button component (no custom styles beyond positioning)
   - Add subtle shadow for visibility over map
   - Use z-10 for layering above map

**MapLibreMap.tsx modifications:**

1. Accept new props from parent:
   - `onBoundsChange?: (bounds: MapBounds) => void` - callback when map moves
   - `isStale?: boolean` - whether to show the button
   - `onSearchThisArea?: () => void` - callback for button click
   - `isSearching?: boolean` - loading state for button

2. Add onMoveEnd handler that:
   - Gets current bounds via mapRef.current.getBounds()
   - Converts to MapBounds format (ne_lat, ne_lng, sw_lat, sw_lng as strings, toFixed(6))
   - Calls onBoundsChange callback with the bounds
   - Does NOT call onBoundsChange during programmatic fitBounds (see step 3)

3. Prevent infinite loop by tracking programmatic moves:
   - Add a ref `isProgrammaticMove` (useRef<boolean>)
   - Set it to true BEFORE calling fitBounds in the businesses useEffect
   - Set it to false in onMoveEnd AFTER checking (use setTimeout with 0ms to ensure it clears after fitBounds completes)
   - Only call onBoundsChange when isProgrammaticMove is false

4. Render SearchThisAreaButton:
   - Position it inside a relative wrapper
   - Show only when isStale is true
   - Pass isSearching to button's isLoading prop
   - Wire onClick to onSearchThisArea prop

The button should appear at bottom center of the map area, floating above the map.
  </action>
  <verify>
- `ls components/map/SearchThisAreaButton.tsx` confirms file created
- `grep -n "onMoveEnd" components/map/MapLibreMap.tsx` shows handler
- `grep -n "onBoundsChange" components/map/MapLibreMap.tsx` shows prop
- `grep -n "isProgrammaticMove" components/map/MapLibreMap.tsx` shows loop prevention
- `grep -n "SearchThisAreaButton" components/map/MapLibreMap.tsx` shows import and usage
- `npx tsc --noEmit` passes
  </verify>
  <done>
SearchThisAreaButton component exists. MapLibreMap has onMoveEnd handler, onBoundsChange callback, isProgrammaticMove ref for loop prevention, and conditionally renders SearchThisAreaButton. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire search page with stale state and visual dimming</name>
  <files>app/search/page.tsx</files>
  <action>
Connect the extended useMapSearch hook to the search page and add visual feedback:

1. Destructure new exports from useMapSearch:
   - `isStale`, `setIsStale`, `searchBounds`, `currentBounds`

2. Create handlers for MapLibreMap props:
   - `handleBoundsChange`: Receives bounds from map, calls setIsStale(true) and stores viewport bounds in local state
   - `handleSearchThisArea`: Calls searchBounds with the stored viewport bounds, sets isStale(false)

3. Add local state for viewportBounds:
   - `const [viewportBounds, setViewportBounds] = useState<MapBounds | null>(null)`
   - Updated by handleBoundsChange
   - Used by handleSearchThisArea

4. Pass new props to MapLibreMap component (in both map-only and split views):
   - `onBoundsChange={handleBoundsChange}`
   - `isStale={isStale}`
   - `onSearchThisArea={handleSearchThisArea}`
   - `isSearching={isLoading}`

5. Add visual dimming for stale results:
   - Wrap the business cards/list container in a div with conditional opacity
   - Use Tailwind: `className={cn("transition-opacity duration-300", isStale ? "opacity-50" : "opacity-100")}`
   - Apply to both list view grid and split view list column
   - Import `cn` from @/lib/utils if not already imported

6. Clear bounds when distance filter changes:
   - In the distance Select onChange, also clear ne_lat, ne_lng, sw_lat, sw_lng from filters
   - This makes UX sense: changing distance should switch back to radius mode

Important: The MapBounds type should match what useMapSearch expects (ne_lat, ne_lng, sw_lat, sw_lng as strings).
  </action>
  <verify>
- `grep -n "isStale" app/search/page.tsx` shows hook usage
- `grep -n "handleBoundsChange" app/search/page.tsx` shows callback
- `grep -n "handleSearchThisArea" app/search/page.tsx` shows button handler
- `grep -n "onBoundsChange" app/search/page.tsx` shows prop passed to map
- `grep -n "opacity-50" app/search/page.tsx` shows stale dimming
- `npx tsc --noEmit` passes
- `npm run build` passes
  </verify>
  <done>
Search page destructures isStale, searchBounds from hook. Handlers wire map callbacks. MapLibreMap receives onBoundsChange, isStale, onSearchThisArea, isSearching props. Business list/cards have opacity transition for stale state. Build succeeds.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the full integration:

1. TypeScript compilation: `npx tsc --noEmit`
2. Production build: `npm run build`
3. Manual testing flow:
   - Visit /search page
   - Let results load (no button visible)
   - Pan or zoom the map
   - "Search this area" button should appear at bottom center
   - Results should dim (opacity 50%)
   - Click the button
   - Button should show loading spinner
   - New results should load and button should disappear
   - Results should return to full opacity
   - URL should contain ne_lat, ne_lng, sw_lat, sw_lng params
   - Refreshing page should restore the same map view
</verification>

<success_criteria>
- "Search this area" button appears after user pans/zooms the map (not after fitBounds)
- Clicking button fetches businesses within current map bounds
- URL reflects current map position (shareable links work)
- No infinite loops between map and search updates
- Results visually dim while stale to indicate they may not match current view
- TypeScript compiles without errors
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-map-to-search-sync/04-01-SUMMARY.md`
</output>
