---
phase: 04-missing-email-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - lib/email.ts
  - lib/auth/two-factor.ts
  - app/api/auth/2fa/send-code/route.ts
  - app/api/auth/2fa/setup/route.ts
  - app/api/auth/2fa/verify/route.ts
autonomous: true

must_haves:
  truths:
    - "User selecting EMAIL 2FA receives a real email with 6-digit code"
    - "2FA code expires after 10 minutes"
    - "Used codes cannot be reused"
    - "User cannot spam resend (60-second cooldown)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "twoFactorCode and twoFactorCodeExpires fields on User model"
      contains: "twoFactorCode"
    - path: "lib/email.ts"
      provides: "send2FACodeEmail function"
      exports: ["send2FACodeEmail"]
    - path: "lib/auth/two-factor.ts"
      provides: "generateAndSendEmailCode, verifyEmailCode functions"
      exports: ["generateAndSendEmailCode", "verifyEmailCode"]
    - path: "app/api/auth/2fa/send-code/route.ts"
      provides: "POST endpoint to send 2FA code via email"
      exports: ["POST"]
  key_links:
    - from: "app/api/auth/2fa/send-code/route.ts"
      to: "lib/auth/two-factor.ts"
      via: "generateAndSendEmailCode call"
      pattern: "generateAndSendEmailCode"
    - from: "lib/auth/two-factor.ts"
      to: "lib/email.ts"
      via: "send2FACodeEmail call"
      pattern: "send2FACodeEmail"
    - from: "lib/auth/two-factor.ts"
      to: "prisma"
      via: "stores code in twoFactorCode field"
      pattern: "twoFactorCode.*twoFactorCodeExpires"
---

<objective>
Implement real 2FA email code delivery for the EMAIL 2FA method.

Purpose: Users who select EMAIL as their 2FA method currently see console logs instead of receiving actual emails. This completes FEAT-01 by wiring the existing email infrastructure to 2FA.

Output: Working 2FA email flow - user gets real email with 6-digit code, code verifies correctly, codes expire and can't be reused.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-missing-email-features/04-RESEARCH.md

# Key existing files
@lib/email.ts
@lib/auth/two-factor.ts
@app/api/auth/2fa/setup/route.ts
@app/api/auth/2fa/verify/route.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add temporary 2FA code fields to User model</name>
  <files>prisma/schema.prisma</files>
  <action>
Add two fields to the User model for temporary 2FA code storage:

```prisma
// Two-Factor Code (for EMAIL/SMS methods)
twoFactorCode        String?
twoFactorCodeExpires DateTime?
```

Add these fields after the existing `twoFactorBackupCodes` field (around line 343).

Then run:
```bash
npx prisma db push
npx prisma generate
```

This enables server-side code storage with expiry, required for email 2FA verification.
  </action>
  <verify>
`npx prisma db push` completes without errors. `npx prisma generate` completes. New fields visible in Prisma client types.
  </verify>
  <done>
User model has twoFactorCode (String?) and twoFactorCodeExpires (DateTime?) fields. Prisma client regenerated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add send2FACodeEmail function and update two-factor.ts</name>
  <files>lib/email.ts, lib/auth/two-factor.ts</files>
  <action>
**In lib/email.ts**, add `send2FACodeEmail` function following existing template pattern:

```typescript
export async function send2FACodeEmail(email: string, code: string): Promise<void> {
  await getResend().emails.send({
    from: `${APP_NAME} <${FROM_EMAIL}>`,
    to: email,
    subject: `Your ${APP_NAME} verification code`,
    html: `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: #f4f4f5; margin: 0; padding: 20px;">
          <div style="max-width: 600px; margin: 0 auto; background-color: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
            <div style="background: linear-gradient(135deg, #16a34a 0%, #059669 100%); padding: 40px 20px; text-align: center;">
              <h1 style="color: white; margin: 0; font-size: 28px;">${APP_NAME}</h1>
              <p style="color: rgba(255,255,255,0.9); margin-top: 8px;">Verification Code</p>
            </div>
            <div style="padding: 40px 30px; text-align: center;">
              <p style="color: #4b5563; line-height: 1.6;">
                Your verification code is:
              </p>
              <div style="background: #f9fafb; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <p style="font-size: 32px; font-weight: bold; color: #111827; letter-spacing: 8px; margin: 0;">${code}</p>
              </div>
              <p style="color: #6b7280; font-size: 14px; line-height: 1.6;">
                This code will expire in 10 minutes. If you didn't request this code, you can safely ignore this email.
              </p>
            </div>
          </div>
        </body>
      </html>
    `,
  });
}
```

**In lib/auth/two-factor.ts**, add imports and new functions:

1. Add import at top:
```typescript
import { prisma } from "@/lib/prisma";
import { send2FACodeEmail } from "@/lib/email";
```

2. Add new functions:

```typescript
/**
 * Generate and send a 2FA code via email
 * Stores code in database with 10-minute expiry
 */
export async function generateAndSendEmailCode(userId: string, email: string): Promise<boolean> {
  const code = generateEmailSmsCode();
  const expires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

  await prisma.user.update({
    where: { id: userId },
    data: {
      twoFactorCode: code,
      twoFactorCodeExpires: expires,
    },
  });

  await send2FACodeEmail(email, code);
  return true;
}

/**
 * Verify a 2FA code for email/SMS methods
 * Returns true if valid, clears code after successful verification
 */
export async function verifyEmailCode(userId: string, code: string): Promise<boolean> {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { twoFactorCode: true, twoFactorCodeExpires: true },
  });

  if (!user?.twoFactorCode || !user?.twoFactorCodeExpires) return false;
  if (new Date() > user.twoFactorCodeExpires) return false;
  if (user.twoFactorCode !== code) return false;

  // Clear code after successful verification (single use)
  await prisma.user.update({
    where: { id: userId },
    data: { twoFactorCode: null, twoFactorCodeExpires: null },
  });

  return true;
}
```

3. Update existing `sendTwoFactorEmail` to call the real function (replace the placeholder):
```typescript
export async function sendTwoFactorEmail(email: string, code: string): Promise<boolean> {
  try {
    await send2FACodeEmail(email, code);
    return true;
  } catch (error) {
    console.error("[2FA] Failed to send email code:", error);
    return false;
  }
}
```
  </action>
  <verify>
TypeScript compiles without errors. Functions are exported from both files.
  </verify>
  <done>
- `send2FACodeEmail` function in lib/email.ts sends branded HTML email
- `generateAndSendEmailCode` generates code, stores in DB, sends email
- `verifyEmailCode` checks code against DB, enforces expiry, clears after use
- `sendTwoFactorEmail` updated to call real email function
  </done>
</task>

<task type="auto">
  <name>Task 3: Create send-code endpoint and update setup/verify routes</name>
  <files>app/api/auth/2fa/send-code/route.ts, app/api/auth/2fa/setup/route.ts, app/api/auth/2fa/verify/route.ts</files>
  <action>
**Create new file `app/api/auth/2fa/send-code/route.ts`:**

```typescript
import { NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { generateAndSendEmailCode } from "@/lib/auth/two-factor";

// POST /api/auth/2fa/send-code - Send 2FA code via email
export async function POST(req: Request) {
  try {
    const session = await auth();

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        email: true,
        twoFactorMethod: true,
        twoFactorCodeExpires: true,
      },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    if (user.twoFactorMethod !== "EMAIL") {
      return NextResponse.json(
        { error: "Email 2FA is not enabled for this account" },
        { status: 400 }
      );
    }

    // Rate limiting: 60-second cooldown between sends
    if (user.twoFactorCodeExpires) {
      const cooldownEnd = new Date(user.twoFactorCodeExpires.getTime() - 9 * 60 * 1000); // 10 min - 9 min = 1 min from creation
      if (new Date() < cooldownEnd) {
        const secondsLeft = Math.ceil((cooldownEnd.getTime() - Date.now()) / 1000);
        return NextResponse.json(
          { error: `Please wait ${secondsLeft} seconds before requesting a new code` },
          { status: 429 }
        );
      }
    }

    await generateAndSendEmailCode(user.id, user.email);

    return NextResponse.json({
      success: true,
      message: "Verification code sent to your email",
    });
  } catch (error) {
    console.error("Send 2FA code error:", error);
    return NextResponse.json(
      { error: "Failed to send verification code" },
      { status: 500 }
    );
  }
}
```

**Update `app/api/auth/2fa/setup/route.ts`:**

In the POST handler, after `} else if (method === "SMS" || method === "EMAIL") {` block (around line 73-86), update to send a code immediately for EMAIL:

```typescript
} else if (method === "EMAIL") {
  // For Email, send code immediately for verification
  await prisma.user.update({
    where: { id: user.id },
    data: {
      twoFactorMethod: "EMAIL",
    },
  });

  // Send initial verification code
  const { generateAndSendEmailCode } = await import("@/lib/auth/two-factor");
  await generateAndSendEmailCode(user.id, user.email);

  return NextResponse.json({
    success: true,
    method: "EMAIL",
    message: "A verification code has been sent to your email. Enter it to complete setup.",
  });
}
```

Remove SMS from the method validation or keep it for now (will be cleaned up in Plan 02).

**Update `app/api/auth/2fa/verify/route.ts`:**

In the verification logic (around line 79-82), add handling for EMAIL method:

Add import at top:
```typescript
import { verifyEmailCode } from "@/lib/auth/two-factor";
```

Update the verification section (after the backup code check, around line 79):
```typescript
if (isBackupCode) {
  // Verify backup code (existing code)
  const result = await verifyBackupCode(code, user.twoFactorBackupCodes);
  isValid = result.valid;
  usedBackupCodeIndex = result.usedIndex;
} else if (user.twoFactorMethod === "EMAIL") {
  // Verify email code
  isValid = await verifyEmailCode(user.id, code);
} else {
  // Verify TOTP code (authenticator)
  isValid = verifyTwoFactorToken(code, user.twoFactorSecret!);
}
```

Also update the PUT handler in setup/route.ts to handle EMAIL verification (around line 139-155):
```typescript
if (user.twoFactorMethod === "AUTHENTICATOR") {
  if (!user.twoFactorSecret) {
    return NextResponse.json(
      { error: "Please set up 2FA first" },
      { status: 400 }
    );
  }
  const isValid = verifyTwoFactorToken(code, user.twoFactorSecret);
  if (!isValid) {
    return NextResponse.json(
      { error: "Invalid verification code" },
      { status: 400 }
    );
  }
} else if (user.twoFactorMethod === "EMAIL") {
  const { verifyEmailCode } = await import("@/lib/auth/two-factor");
  const isValid = await verifyEmailCode(user.id, code);
  if (!isValid) {
    return NextResponse.json(
      { error: "Invalid or expired verification code" },
      { status: 400 }
    );
  }
}
```
  </action>
  <verify>
1. `npm run build` completes without errors
2. Manual test: Select EMAIL 2FA in security settings, receive actual email with code
3. Verify code works and enables 2FA
4. Test expired code is rejected (wait 10+ min or manually expire in DB)
5. Test cooldown prevents rapid resends
  </verify>
  <done>
- New `/api/auth/2fa/send-code` endpoint sends email codes with 60-second cooldown
- `/api/auth/2fa/setup` POST sends code immediately for EMAIL method
- `/api/auth/2fa/setup` PUT verifies EMAIL codes via verifyEmailCode
- `/api/auth/2fa/verify` POST handles EMAIL codes during login
- Codes expire after 10 minutes and are single-use
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Email 2FA flow works end-to-end:
   - Go to /settings/security
   - Click "Email Verification"
   - Receive real email with 6-digit code
   - Enter code, 2FA is enabled
3. Code security:
   - Code expires after 10 minutes
   - Code cannot be reused after successful verification
   - 60-second cooldown between send requests
</verification>

<success_criteria>
- FEAT-01 complete: 2FA codes sent via real email (not console.log)
- Codes stored in database with twoFactorCode and twoFactorCodeExpires fields
- 10-minute expiry enforced
- Single-use enforcement (code cleared after verification)
- 60-second cooldown between sends
- Matches existing email template branding
</success_criteria>

<output>
After completion, create `.planning/phases/04-missing-email-features/04-01-SUMMARY.md`
</output>
